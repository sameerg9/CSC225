{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 STIXGeneral-Regular;\f2\fnil\fcharset0 CambriaMath;
}
{\colortbl;\red255\green255\blue255;\red27\green29\blue31;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c14118\c15294\c16078;\cssrgb\c100000\c100000\c100000;}
\margl1440\margr1440\vieww16980\viewh12060\viewkind0
\deftab720
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0\fs30 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What you are trying to do is correct. However only number of rotations will not be able to tell you anything about the inversions. The whole procedure is as follows.\
You start with an empty red-black tree. Then you insert the elements in the given sequence one by one, in the order that they occur in the sequence.\
Whenever an element \
\pard\pardeftab720\sl580\partightenfactor0

\f1\i\fs37\fsmilli18600 \cf2 \up0 x
\f0\i0 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f2\fs30 \cf2 \cb3 x\cb1 \up0 \
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0 \cf2 \cb3  in the sequence is inserted, the elements larger than \
\pard\pardeftab720\sl580\partightenfactor0

\f1\i\fs37\fsmilli18600 \cf2 \up0 x
\f0\i0 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f2\fs30 \cf2 \cb3 x\cb1 \up0 \
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0 \cf2 \cb3  already existing in the red-black tree are inversions. You need to calculate this number.\
You total up all the inversions for all elements and you get the total number of inversions.\
You need to augment the red-black tree by keeping the size of sub-trees in the interior nodes. Then you can find the number of elements larger than \
\pard\pardeftab720\sl580\partightenfactor0

\f1\i\fs37\fsmilli18600 \cf2 \up0 x
\f0\i0 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f2\fs30 \cf2 \cb3 x\cb1 \up0 \
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0 \cf2 \cb3  either during insertion or after insertions by doing a search of element \
\pard\pardeftab720\sl580\partightenfactor0

\f1\i\fs37\fsmilli18600 \cf2 \up0 x
\f0\i0 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f2\fs30 \cf2 \cb3 x\cb1 \up0 \
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0 \cf2 \cb3 .\
Since you are confused about the strategy, I suggest you should use the second method. Don't count the larger elements during the insertion stage. Count them immediately after the insertion is done and before another insertion is to be done (in a separate function). This will take additional \
\pard\pardeftab720\sl580\partightenfactor0

\f1\i\fs37\fsmilli18600 \cf2 \up0 O
\i0 (log
\i n
\i0 )
\f0 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f2\fs30 \cf2 \cb3 O\cb1 \up0 \
\cb3 \up0 (\cb1 \up0 \
\cb3 \up0 log\cb1 \up0 \
\cb3 \up0 \uc0\u8289 \cb1 \up0 \
\cb3 \up0 n\cb1 \up0 \
\cb3 \up0 )\cb1 \up0 \
\pard\pardeftab720\sl340\sa300\partightenfactor0

\f0 \cf2 \cb3  on the augmented tree.\
If all your numbers are distinct then this algorithm suffices. However, if some numbers are same, then you have to modify your insertion to insert only at the rightmost possible position and/or counting only the strictly larger elements depending on your algorithm. You will need to further augment the data structure to hold the min-value and max-value of the sub-tree in the node.\
}